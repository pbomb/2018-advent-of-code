// Generated by BUCKLESCRIPT VERSION 4.0.18, PLEASE EDIT WITH CARE
'use strict';

var Util = require("../Util.bs.js");
var Belt_Id = require("bs-platform/lib/js/belt_Id.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_format = require("bs-platform/lib/js/caml_format.js");
var Belt_MutableMap = require("bs-platform/lib/js/belt_MutableMap.js");

function cmp(param, param$1) {
  var c = Caml_obj.caml_compare(param[0], param$1[0]);
  if (c !== 0) {
    return c;
  } else {
    return Caml_obj.caml_compare(param[1], param$1[1]);
  }
}

var SquareHitCmp = Belt_Id.MakeComparable(/* module */[/* cmp */cmp]);

function parseClaim(claimLine) {
  var claimParts = claimLine.split(" ");
  var arg = Caml_array.caml_array_get(claimParts, 2);
  var edgeParts = Belt_Array.map((function (param) {
                return (function (param$1) {
                    return arg.slice(param, param$1);
                  });
              })(0)(-1).split(","), Caml_format.caml_int_of_string);
  var dimensionParts = Belt_Array.map(Caml_array.caml_array_get(claimParts, 3).split("x"), Caml_format.caml_int_of_string);
  var arg$1 = Caml_array.caml_array_get(claimParts, 0);
  return /* record */[
          /* id */Caml_format.caml_int_of_string((function (param) {
                    return arg$1.substring(param);
                  })(1)),
          /* fromEdges : tuple */[
            Caml_array.caml_array_get(edgeParts, 0),
            Caml_array.caml_array_get(edgeParts, 1)
          ],
          /* dimensions : tuple */[
            Caml_array.caml_array_get(dimensionParts, 0),
            Caml_array.caml_array_get(dimensionParts, 1)
          ]
        ];
}

function addSquaresFromClaim(aClaim, claimMap) {
  var match = aClaim[/* fromEdges */1];
  var edgeY = match[1];
  var edgeX = match[0];
  var match$1 = aClaim[/* dimensions */2];
  var ySize = match$1[1];
  for(var x = edgeX ,x_finish = (edgeX + match$1[0] | 0) - 1 | 0; x <= x_finish; ++x){
    for(var y = edgeY ,y_finish = (edgeY + ySize | 0) - 1 | 0; y <= y_finish; ++y){
      var existingCountForSquare = Belt_MutableMap.get(claimMap, /* tuple */[
            x,
            y
          ]);
      Belt_MutableMap.set(claimMap, /* tuple */[
            x,
            y
          ], existingCountForSquare !== undefined ? existingCountForSquare + 1 | 0 : 1);
    }
  }
  return /* () */0;
}

function calculateClaimsPerLocation(claims) {
  var claimMap = Belt_MutableMap.make(SquareHitCmp);
  Belt_List.forEach(claims, (function (aClaim) {
          return addSquaresFromClaim(aClaim, claimMap);
        }));
  return claimMap;
}

function squaresWithOverlap(overlaps) {
  return Belt_MutableMap.reduce(overlaps, 0, (function (total, _key, value) {
                var match = value > 1;
                if (match) {
                  return total + 1 | 0;
                } else {
                  return total;
                }
              }));
}

console.log(squaresWithOverlap(calculateClaimsPerLocation(Belt_List.map(Belt_List.fromArray(Util.readLinesOfFile("day3.txt")), parseClaim))));

exports.SquareHitCmp = SquareHitCmp;
exports.parseClaim = parseClaim;
exports.addSquaresFromClaim = addSquaresFromClaim;
exports.calculateClaimsPerLocation = calculateClaimsPerLocation;
exports.squaresWithOverlap = squaresWithOverlap;
/* SquareHitCmp Not a pure module */
