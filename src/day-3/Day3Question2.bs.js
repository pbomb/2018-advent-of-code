// Generated by BUCKLESCRIPT VERSION 5.0.2, PLEASE EDIT WITH CARE
'use strict';

var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Day3Util = require("./Day3Util.bs.js");
var Belt_List = require("bs-platform/lib/js/belt_List.js");
var Belt_Array = require("bs-platform/lib/js/belt_Array.js");
var Belt_MutableSetInt = require("bs-platform/lib/js/belt_MutableSetInt.js");

function range(start, end_) {
  if (start > end_) {
    return /* [] */0;
  } else {
    return /* :: */[
            start,
            range(start + 1 | 0, end_)
          ];
  }
}

function toEdges(param) {
  var match = param[/* dimensions */2];
  var match$1 = param[/* fromEdges */1];
  var yStart = match$1[1];
  var xStart = match$1[0];
  var xEnd = (xStart + match[0] | 0) - 1 | 0;
  var yEnd = (yStart + match[1] | 0) - 1 | 0;
  return /* record */[
          /* id */param[/* id */0],
          /* xStart */xStart,
          /* yStart */yStart,
          /* xEnd */xEnd,
          /* yEnd */yEnd,
          /* edges */Belt_List.concatMany(/* array */[
                Belt_List.map(range(xStart, xEnd), (function (x) {
                        return /* tuple */[
                                x,
                                yStart
                              ];
                      })),
                Belt_List.map(range(xStart, xEnd), (function (x) {
                        return /* tuple */[
                                x,
                                yEnd - 1 | 0
                              ];
                      })),
                Belt_List.map(range(yStart, yEnd), (function (y) {
                        return /* tuple */[
                                xStart,
                                y
                              ];
                      })),
                Belt_List.map(range(yStart, yEnd), (function (y) {
                        return /* tuple */[
                                xEnd - 1 | 0,
                                y
                              ];
                      }))
              ])
        ];
}

function withinRegion(param, param$1) {
  var y = param$1[1];
  var x = param$1[0];
  if (x >= param[/* xStart */1] && x <= param[/* xEnd */3] && y >= param[/* yStart */2]) {
    return y <= param[/* yEnd */4];
  } else {
    return false;
  }
}

function regionsOverlap(region1, region2) {
  return Belt_List.some(region1[/* edges */5], (function (param) {
                return withinRegion(region2, param);
              }));
}

function markOverlaps(remainingRegions, overlaps, region) {
  return Belt_List.forEach(remainingRegions, (function (remainingRegion) {
                var bothAlreadyMarked = Belt_List.every(/* :: */[
                      remainingRegion,
                      /* :: */[
                        region,
                        /* [] */0
                      ]
                    ], (function (r) {
                        return Belt_MutableSetInt.has(overlaps, r[/* id */0]);
                      }));
                if (Caml_obj.caml_notequal(remainingRegion, region) && !bothAlreadyMarked && regionsOverlap(remainingRegion, region)) {
                  return Belt_List.forEach(/* :: */[
                              remainingRegion,
                              /* :: */[
                                region,
                                /* [] */0
                              ]
                            ], (function (r) {
                                return Belt_MutableSetInt.add(overlaps, r[/* id */0]);
                              }));
                } else {
                  return 0;
                }
              }));
}

function regionsWithoutOverlap(regions) {
  var overlaps = Belt_MutableSetInt.make(/* () */0);
  Belt_List.forEach(regions, (function (param) {
          return markOverlaps(regions, overlaps, param);
        }));
  return Belt_List.keep(regions, (function (r) {
                return !Belt_MutableSetInt.has(overlaps, r[/* id */0]);
              }));
}

function logRegion(regions) {
  if (regions) {
    var match = Belt_List.length(regions[1]) === 0;
    if (match) {
      console.log(regions[0][/* id */0]);
      return /* () */0;
    } else {
      console.log(Belt_Array.map(Belt_List.toArray(regions), (function (r) {
                  return r[/* id */0];
                })));
      return /* () */0;
    }
  } else {
    console.log("Could not find region without overlaps");
    return /* () */0;
  }
}

logRegion(regionsWithoutOverlap(Belt_List.map(Day3Util.readClaims(/* () */0), toEdges)));

exports.range = range;
exports.toEdges = toEdges;
exports.withinRegion = withinRegion;
exports.regionsOverlap = regionsOverlap;
exports.markOverlaps = markOverlaps;
exports.regionsWithoutOverlap = regionsWithoutOverlap;
exports.logRegion = logRegion;
/*  Not a pure module */
